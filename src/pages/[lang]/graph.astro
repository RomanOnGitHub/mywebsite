---
import Layout from '@/layouts/Layout.astro';
import { SUPPORTED_LOCALES, type Locale } from '@/utils/slugs';

export function getStaticPaths() {
  return SUPPORTED_LOCALES.map(lang => ({ 
    params: { lang } 
  }));
}

const { lang } = Astro.params as { lang: Locale };
---

<Layout 
  title="Граф знаний" 
  description="Интерактивная визуализация связей между материалами"
  lang={lang}
>
  <div class="max-w-7xl mx-auto">
    <header class="mb-8">
      <h1 class="text-4xl font-bold mb-4">Граф знаний</h1>
      <p class="text-lg text-gray-600 dark:text-gray-400">
        Исследуйте связи между материалами сайта
      </p>
    </header>
    
    <!-- Фильтры -->
    <div class="mb-6 flex flex-wrap gap-4 items-center">
      <div class="flex items-center gap-2">
        <label for="filter-type" class="text-sm font-medium text-gray-700 dark:text-gray-300">
          Тип:
        </label>
        <select 
          id="filter-type"
          class="border border-gray-300 dark:border-gray-600 rounded-md px-3 py-2 bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100 focus:ring-2 focus:ring-blue-500"
        >
          <option value="">Все типы</option>
          <option value="blog">Блог</option>
          <option value="cases">Кейсы</option>
          <option value="services">Услуги</option>
          <option value="industries">Отрасли</option>
        </select>
      </div>
      
      <div class="flex items-center gap-2">
        <label for="filter-tags" class="text-sm font-medium text-gray-700 dark:text-gray-300">
          Тег:
        </label>
        <select 
          id="filter-tags"
          class="border border-gray-300 dark:border-gray-600 rounded-md px-3 py-2 bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100 focus:ring-2 focus:ring-blue-500"
        >
          <option value="">Все теги</option>
          <!-- Динамически заполняется из graph.nodes -->
        </select>
      </div>
      
      <button
        id="reset-filters"
        class="px-4 py-2 bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 text-gray-800 dark:text-gray-200 rounded-md transition-colors text-sm"
      >
        Сбросить фильтры
      </button>
    </div>
    
    <!-- Контейнер для графа -->
    <div 
      id="graph-container" 
      class="border border-gray-200 dark:border-gray-700 rounded-lg bg-white dark:bg-gray-800 overflow-hidden relative"
      style="width: 100%; height: 600px;"
    ></div>
    
    <!-- Легенда -->
    <div class="mt-6 flex flex-wrap gap-4 text-sm">
      <div class="flex items-center gap-2">
        <div class="w-4 h-4 rounded-full bg-blue-500"></div>
        <span>Блог</span>
      </div>
      <div class="flex items-center gap-2">
        <div class="w-4 h-4 rounded-full bg-green-500"></div>
        <span>Кейсы</span>
      </div>
      <div class="flex items-center gap-2">
        <div class="w-4 h-4 rounded-full bg-yellow-500"></div>
        <span>Услуги</span>
      </div>
      <div class="flex items-center gap-2">
        <div class="w-4 h-4 rounded-full bg-purple-500"></div>
        <span>Отрасли</span>
      </div>
    </div>
  </div>
</Layout>

<script>
  import ForceGraph from 'force-graph';
  import * as d3 from 'd3-force';
  
  let graph: any = null;
  let allData: { nodes: any[]; edges: any[] } | null = null;
  const lang = document.documentElement.lang || 'ru';
  
  async function init() {
    try {
      const res = await fetch(`/graph-data-${lang}.json`);
      if (!res.ok) {
        console.error('Failed to load graph data');
        return;
      }
      
      allData = await res.json();
      
      // Заполнить select с тегами
      const allTags = [...new Set(allData.nodes.flatMap((n: any) => n.tags || []))].sort();
      const tagsSelect = document.getElementById('filter-tags') as HTMLSelectElement;
      
      // Очистить существующие опции (кроме "Все теги")
      while (tagsSelect.options.length > 1) {
        tagsSelect.remove(1);
      }
      
      allTags.forEach(tag => {
        const option = document.createElement('option');
        option.value = tag;
        option.textContent = tag;
        tagsSelect.appendChild(option);
      });
      
      renderGraph(allData);
    } catch (error) {
      console.error('Error loading graph data:', error);
    }
  }
  
  function applyFilters() {
    if (!allData) return;
    
    const typeSelect = document.getElementById('filter-type') as HTMLSelectElement;
    const tagSelect = document.getElementById('filter-tags') as HTMLSelectElement;
    
    const type = typeSelect.value;
    const tag = tagSelect.value;
    
    const filteredNodes = allData.nodes.filter((n: any) => 
      (!type || n.type === type) &&
      (!tag || (n.tags && n.tags.includes(tag)))
    );
    
    const nodeIds = new Set(filteredNodes.map((n: any) => n.id));
    const filteredEdges = allData.edges.filter((e: any) => 
      nodeIds.has(e.from) && nodeIds.has(e.to)
    );
    
    renderGraph({ nodes: filteredNodes, edges: filteredEdges });
  }
  
  function renderGraph(data: { nodes: any[]; edges: any[] }) {
    const container = document.getElementById('graph-container');
    if (!container) return;
    
    // Уничтожить предыдущий граф
    if (graph) {
      graph._destructor();
    }
    
    // Получаем реальные размеры контейнера через getBoundingClientRect
    const rect = container.getBoundingClientRect();
    const width = rect.width || container.clientWidth || 800;
    const height = rect.height || container.clientHeight || 600;
    const margin = 30; // Отступ от краёв
    
    // Вычисляем центр контейнера
    // Используем Math.floor для целочисленных координат
    const centerX = Math.floor(width / 2);
    const centerY = Math.floor(height / 2);
    
    // Отладочная информация (можно убрать после проверки)
    console.log('Graph container:', { width, height, centerX, centerY });
    
    // Преобразовать edges в links для force-graph
    const links = data.edges.map((e: any) => ({
      source: e.from,
      target: e.to,
    }));
    
    // Вычисляем размеры узлов для учёта в границах
    const nodeSizes = new Map();
    data.nodes.forEach((node: any) => {
      const connections = data.edges.filter((e: any) => 
        e.from === node.id || e.to === node.id
      ).length;
      const size = Math.max(5, Math.min(20, connections * 2));
      nodeSizes.set(node.id, size);
    });
    
    // Кастомная сила для мягкого ограничения границ
    // Корректирует скорости узлов, когда они выходят за пределы
    // Это не хардкод - мы не устанавливаем позиции, а только корректируем скорости
    const boundingBoxForce = () => {
      let nodes: any[];
      
      const force = (alpha: number) => {
        nodes.forEach((node: any) => {
          const nodeSize = nodeSizes.get(node.id) || 10;
          const xMin = margin + nodeSize;
          const xMax = width - margin - nodeSize;
          const yMin = margin + nodeSize;
          const yMax = height - margin - nodeSize;
          
          // Корректируем скорость, если узел выходит за границы
          // Используем коэффициент 0.1 для мягкости
          if (node.x! < xMin) {
            node.vx = (node.vx || 0) + (xMin - node.x!) * 0.1;
          }
          if (node.x! > xMax) {
            node.vx = (node.vx || 0) + (xMax - node.x!) * 0.1;
          }
          if (node.y! < yMin) {
            node.vy = (node.vy || 0) + (yMin - node.y!) * 0.1;
          }
          if (node.y! > yMax) {
            node.vy = (node.vy || 0) + (yMax - node.y!) * 0.1;
          }
        });
      };
      
      force.initialize = (n: any[]) => {
        nodes = n;
      };
      
      return force;
    };
    
    // Устанавливаем начальные позиции узлов ПЕРЕД созданием графа
    // Это гарантирует, что позиции будут использованы при инициализации
    data.nodes.forEach((node: any, index: number) => {
      // Распределяем узлы равномерно по кругу вокруг центра
      const angle = (index / data.nodes.length) * Math.PI * 2;
      const radius = Math.min(width, height) * 0.1;
      
      // Устанавливаем позиции в центре контейнера
      // Важно: устанавливаем напрямую в объект узла
      node.x = centerX + Math.cos(angle) * radius;
      node.y = centerY + Math.sin(angle) * radius;
      
      // Инициализируем скорости в 0
      node.vx = 0;
      node.vy = 0;
    });
    
    // Создать граф
    graph = ForceGraph()(container)
      .graphData({ nodes: data.nodes, links })
      .width(width)
      .height(height)
      .nodeLabel((n: any) => n.title)
      .nodeColor((n: any) => {
        const colors: Record<string, string> = {
          blog: '#3b82f6',
          cases: '#10b981',
          services: '#f59e0b',
          industries: '#8b5cf6',
        };
        return colors[n.type] || '#6b7280';
      })
      .nodeVal((n: any) => nodeSizes.get(n.id) || 10)
      .linkWidth(1)
      .linkDirectionalArrowLength(6)
      .linkDirectionalArrowRelPos(1)
      .d3Force('center', d3.forceCenter(width / 2, height / 2))
      .d3Force('charge', d3.forceManyBody().strength(-300))
      .d3Force('link', d3.forceLink(links).id((d: any) => d.id).distance(100))
      .d3Force('boundingBox', boundingBoxForce())
      .onNodeClick((node: any) => {
        window.location.href = `/${lang}/${node.id}/`;
      })
      .onNodeHover((node: any) => {
        if (node) {
          container.style.cursor = 'pointer';
        } else {
          container.style.cursor = 'default';
        }
      });
  }
  
  function resetFilters() {
    const typeSelect = document.getElementById('filter-type') as HTMLSelectElement;
    const tagSelect = document.getElementById('filter-tags') as HTMLSelectElement;
    
    typeSelect.value = '';
    tagSelect.value = '';
    
    if (allData) {
      renderGraph(allData);
    }
  }
  
  // Инициализация
  document.getElementById('filter-type')?.addEventListener('change', applyFilters);
  document.getElementById('filter-tags')?.addEventListener('change', applyFilters);
  document.getElementById('reset-filters')?.addEventListener('click', resetFilters);
  
  // Обновление при View Transitions
  document.addEventListener('astro:page-load', init);
  
  // Первоначальная загрузка
  init();
</script>

# Рефлексия: Почему правила кодревью не выявили проблемы с кэшированием

## Резюме

Правила в `codereviewrule-updated.mdc` не выявили критические проблемы с кэшированием графа знаний, потому что:

1. **Отсутствовала секция про Client-Side Caching** - правила покрывали только серверное кэширование
2. **Неполное покрытие Custom Elements lifecycle** - проверялся только `connectedCallback()`, но не `disconnectedCallback()`
3. **Фокус на функциональности, а не на производительности** - правила проверяли, что код работает, но не как эффективно
4. **Отсутствие требований к анализу взаимодействия компонентов** - не проверялось дублирование запросов между компонентами

## Детальный анализ пропущенных проблем

### 1. Redundant Network Requests (КРИТИЧНО)

**Проблема:**
- Компоненты `Backlinks` и `Recommendations` делали одинаковые fetch запросы на каждой навигации
- На странице блога запрос происходил дважды (Sidebar + LayoutPost)
- Нет кэширования между навигациями

**Почему не выявлено:**
- ❌ Отсутствовала секция про Client-Side Caching
- ❌ Нет проверки на дублирование запросов между компонентами
- ❌ Нет требований к анализу network requests в dev tools
- ❌ Правила проверяли только обработку ошибок (`try/catch`), но не оптимизацию запросов

**Что было в правилах:**
- ✅ "Network requests wrapped in try/catch" - только обработка ошибок
- ✅ "Custom Elements загружают данные из `/graph-data-{lang}.json`" - только источник данных

**Что добавлено:**
- ✅ Новая секция "Client-Side Caching (CRITICAL for View Transitions)"
- ✅ Проверка на дублирование запросов
- ✅ Требование анализа network requests перед коммитом

---

### 2. Memory Leaks в Custom Elements (КРИТИЧНО)

**Проблема:**
- Event listeners не удалялись при размонтировании компонентов
- При навигации listeners накапливались, что приводило к утечкам памяти
- Множественные вызовы `loadBacklinks()` и `loadRecommendations()` при одной навигации

**Почему не выявлено:**
- ❌ Правила проверяли только `connectedCallback()`, но не `disconnectedCallback()`
- ❌ Нет требований к cleanup event listeners
- ❌ Нет проверки на сохранение ссылок на handlers для последующего удаления

**Что было в правилах:**
- ✅ "Custom Elements используют `astro:page-load`" - только добавление listeners
- ❌ Нет требований к удалению listeners

**Что добавлено:**
- ✅ Требование `disconnectedCallback()` для cleanup
- ✅ Проверка удаления event listeners
- ✅ Требование сохранения ссылок на handlers как свойства класса

---

### 3. Отсутствие кэширования между навигациями (ВЫСОКИЙ)

**Проблема:**
- Данные загружались заново при каждой навигации, даже если они не изменились
- View Transitions создают иллюзию SPA, но модули переинициализируются
- Модуль-уровневый кэш не работает в View Transitions

**Почему не выявлено:**
- ❌ Нет правил о персистентности данных между View Transitions
- ❌ Нет требований к кэшированию для SPA-like навигации
- ❌ Нет проверки на использование Cache API или других механизмов кэширования

**Что было в правилах:**
- ✅ "Обработчик `astro:page-load` для обновления клиентских библиотек" - только обновление
- ❌ Нет требований к кэшированию данных

**Что добавлено:**
- ✅ Требование кэширования данных между навигациями
- ✅ Проверка на использование Cache API или memory cache
- ✅ Требование двухуровневого кэширования (memory + Cache API)

---

### 4. Использование window объекта для кэша (СРЕДНИЙ)

**Проблема:**
- Предложенное решение использовало `window.__graphCache`, что загрязняет глобальный namespace
- Риск конфликтов с другими библиотеками
- Сложность тестирования и отладки

**Почему не выявлено:**
- ❌ Нет правил о запрете использования window для хранения данных
- ❌ Нет требований к использованию Cache API вместо window
- ❌ Нет проверки на загрязнение глобального namespace

**Что было в правилах:**
- ✅ "Проверка `typeof window !== 'undefined'`" - только проверка существования
- ❌ Нет правил о правильном способе кэширования

**Что добавлено:**
- ✅ Требование использования Cache API вместо window
- ✅ Проверка на загрязнение глобального namespace
- ✅ Требование инкапсуляции кэша

---

### 5. Отсутствие TTL и инвалидации (СРЕДНИЙ)

**Проблема:**
- Кэш никогда не обновлялся, даже если данные на сервере изменились
- Нет механизма для принудительного обновления
- Риск показа устаревших данных пользователям

**Почему не выявлено:**
- ❌ Полностью отсутствовали правила о TTL для клиентского кэша
- ❌ Нет требований к механизму инвалидации
- ❌ Нет проверки на устаревшие данные

**Что добавлено:**
- ✅ Требование TTL для кэшированных данных
- ✅ Проверка механизма инвалидации
- ✅ Требование версионирования кэша

---

### 6. Отсутствие ограничения памяти (СРЕДНИЙ)

**Проблема:**
- Кэш мог расти бесконечно, особенно при переключении между языками
- 10 языков × ~100KB = ~1MB в памяти без ограничений
- Риск утечек памяти на мобильных устройствах

**Почему не выявлено:**
- ❌ Полностью отсутствовали правила о ограничении памяти
- ❌ Нет требований к LRU eviction или другим стратегиям
- ❌ Нет проверки на утечки памяти в кэше

**Что добавлено:**
- ✅ Требование ограничения размера кэша
- ✅ Проверка стратегии eviction (LRU, FIFO)
- ✅ Требование очистки неиспользуемых данных

---

### 7. Отсутствие метрик (НИЗКИЙ)

**Проблема:**
- Невозможно измерить эффективность кэширования
- Нет данных о hit/miss rate
- Непонятно, работает ли кэш вообще

**Почему не выявлено:**
- ❌ Полностью отсутствовали правила о метриках производительности
- ❌ Нет требований к мониторингу кэша
- ❌ Нет проверки на наличие инструментов для отладки

**Что добавлено:**
- ✅ Требование метрик для кэша (hits, misses, errors, evictions)
- ✅ Проверка наличия инструментов для отладки
- ✅ Требование логирования метрик в dev режиме

---

## Корневые причины пропуска

### 1. Фокус на функциональности, а не на производительности

**Проблема:**
- Правила проверяли, что код работает, но не проверяли, как эффективно он работает
- Нет требований к анализу network requests и производительности
- Нет проверки на дублирование запросов

**Решение:**
- Добавлена секция "Client-Side Caching" с требованиями к производительности
- Требование анализа network requests перед коммитом
- Проверка на дублирование запросов между компонентами

---

### 2. Отсутствие секции про Client-Side Caching

**Проблема:**
- Правила покрывают серверное кэширование (HTTP headers), но не клиентское
- Нет понимания, что View Transitions требуют специального подхода к кэшированию
- Нет требований к персистентности данных между навигациями

**Решение:**
- Добавлена новая секция "Client-Side Caching (CRITICAL for View Transitions)"
- Требования к кэшированию повторяющихся запросов
- Предотвращение дублирования между компонентами
- Использование Cache API вместо window

---

### 3. Неполное покрытие Custom Elements lifecycle

**Проблема:**
- Правила проверяют только `connectedCallback()`, но не `disconnectedCallback()`
- Нет требований к cleanup и предотвращению memory leaks
- Нет проверки на удаление event listeners

**Решение:**
- Расширена секция "Custom Elements"
- Требование `disconnectedCallback()` для cleanup
- Проверка удаления event listeners
- Требование сохранения ссылок на handlers

---

### 4. Отсутствие требований к архитектуре кэширования

**Проблема:**
- Нет правил о выборе механизма кэширования (Cache API vs window vs memory)
- Нет требований к двухуровневому кэшированию
- Нет проверки на правильную архитектуру кэша

**Решение:**
- Добавлены требования к использованию Cache API
- Требование двухуровневого кэширования (memory + Cache API)
- Проверка на правильную архитектуру кэша

---

### 5. Недостаточная проверка edge cases

**Проблема:**
- Правила проверяют основные сценарии, но не edge cases
- Нет требований к анализу взаимодействия компонентов
- Нет проверки на множественные компоненты на одной странице

**Решение:**
- Добавлены требования к анализу взаимодействия компонентов
- Проверка на дублирование запросов между компонентами
- Требование анализа network requests

---

## Добавленные правила

### Новая секция "Client-Side Caching (CRITICAL for View Transitions)"

1. **Кэширование повторяющихся запросов:** Данные, загружаемые на каждой навигации, должны кэшироваться
2. **Предотвращение дублирования:** Одинаковые запросы от разных компонентов должны использовать общий кэш
3. **Cache API предпочтительнее window:** Использовать Cache API или memory cache, НЕ window объект
4. **Проверка SSR для кэша:** Кэш проверяет `typeof window !== 'undefined'` перед использованием
5. **TTL и инвалидация:** Кэшированные данные имеют TTL и механизм инвалидации
6. **Ограничение памяти:** Кэш имеет ограничение размера (LRU eviction)
7. **Обработка ошибок в кэше:** Failed requests не остаются в кэше, есть fallback
8. **Двухуровневое кэширование:** Memory cache + Cache API для оптимальной производительности
9. **Метрики кэша (dev режим):** Логирование метрик (hits, misses, errors, evictions)
10. **Анализ network requests:** Проверка на дублирование запросов в dev tools
11. **Версионирование кэша:** Кэш имеет версию для инвалидации
12. **Graceful degradation:** Если Cache API недоступен, используется memory cache

### Расширенная секция "Custom Elements"

1. **disconnectedCallback() реализован:** Event listeners удаляются при размонтировании
2. **Cleanup handlers:** Ссылки на event handlers сохраняются для последующего удаления
3. **Memory leak prevention:** Все addEventListener имеют соответствующий removeEventListener
4. **Handler references:** Обработчики сохраняются как свойства класса (не inline функции)

### Обновлённая секция "Performance"

- Требования к анализу network requests
- Проверка на дублирование запросов

### Обновлённая секция "Gap Analysis"

- Добавлены проверки на кэширование
- Добавлены проверки на memory leaks
- Добавлены проверки на метрики

### Обновлённая секция "Prioritization"

- Client-Side Caching добавлен в **Critical**
- Custom Elements lifecycle добавлен в **High**
- Cache metrics добавлены в **Medium**

---

## Методология улучшенного кодревью

### Порядок проверки (обновлён)

1. Конфигурационные файлы (первыми — они влияют на всё)
2. Кроссплатформенность и пути
3. Обработка ошибок
4. **Client-Side Caching и Performance** (новое)
5. Custom Elements lifecycle (расширено)
6. Безопасность
7. Остальные категории

### Принципы (дополнены)

- Проверять edge cases, а не только happy path
- Требовать логирование для отладки
- Проверять кроссплатформенность явно
- Верифицировать единый источник правды для env переменных
- Требовать graceful degradation для опциональных зависимостей
- **Проверять не только функциональность, но и производительность** (новое)
- **Требовать кэширование для повторяющихся запросов** (новое)
- **Проверять полный lifecycle Custom Elements (connected + disconnected)** (новое)
- **Требовать метрики для мониторинга производительности** (новое)
- **Анализировать взаимодействие компонентов, а не только отдельные компоненты** (новое)

---

## Выводы

### Почему правила не выявили проблемы

1. **Отсутствие секции про Client-Side Caching** - основная причина
2. **Неполное покрытие Custom Elements lifecycle** - не проверялся cleanup
3. **Фокус на функциональности, а не на производительности** - не проверялась оптимизация
4. **Отсутствие требований к анализу взаимодействия компонентов** - не проверялось дублирование

### Что добавлено

1. **Новая секция "Client-Side Caching"** (12 правил)
2. **Расширенная секция "Custom Elements"** (4 новых правила)
3. **Обновлённая секция "Performance"** (требования к анализу)
4. **Обновлённая секция "Gap Analysis"** (проверки на кэширование)
5. **Обновлённая секция "Prioritization"** (Client-Side Caching в Critical)
6. **Детальная рефлексия** о пропущенных проблемах

### Результат

Правила кодревью теперь покрывают проблемы с кэшированием и memory leaks, которые были пропущены ранее. При следующем кодревью эти проблемы будут выявлены на раннем этапе.

---

## Уроки для будущего

1. **Всегда проверять производительность, а не только функциональность**
2. **Проверять полный lifecycle компонентов (mount + unmount)**
3. **Требовать кэширование для повторяющихся операций**
4. **Анализировать взаимодействие компонентов, а не только отдельные компоненты**
5. **Требовать метрики для мониторинга производительности**

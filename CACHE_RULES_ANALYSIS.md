# Анализ: Почему правила кодревью не выявили проблемы с кэшированием

## Проблемы, которые не были выявлены

### 1. Redundant Network Requests (КРИТИЧНО)
**Проблема:** Компоненты делали одинаковые fetch запросы на каждой навигации, даже если данные уже были загружены.

**Почему не выявлено:**
- ❌ Нет правил о кэшировании клиентских данных
- ❌ Нет проверки на дублирование запросов между компонентами
- ❌ Нет требований к анализу network requests в dev tools

**Что было в правилах:**
- ✅ "Network requests wrapped in try/catch" - только обработка ошибок
- ✅ "Custom Elements загружают данные из `/graph-data-{lang}.json`" - только источник данных

**Что отсутствовало:**
- ❌ Требование кэширования для повторяющихся запросов
- ❌ Проверка на дублирование запросов между компонентами
- ❌ Требование анализа network activity

---

### 2. Memory Leaks в Custom Elements (КРИТИЧНО)
**Проблема:** Event listeners не удалялись при размонтировании компонентов, накапливались при навигации.

**Почему не выявлено:**
- ❌ Нет правил о lifecycle методах Custom Elements
- ❌ Нет требований к cleanup в disconnectedCallback
- ❌ Нет проверки на удаление event listeners

**Что было в правилах:**
- ✅ "Custom Elements используют `astro:page-load`" - только добавление listeners
- ✅ "Обработка ошибок при загрузке данных" - только try/catch

**Что отсутствовало:**
- ❌ Требование `disconnectedCallback()` для cleanup
- ❌ Проверка удаления event listeners
- ❌ Требование сохранения ссылок на handlers для последующего удаления

---

### 3. Отсутствие кэширования между навигациями (ВЫСОКИЙ)
**Проблема:** Данные загружались заново при каждой навигации, даже если они не изменились.

**Почему не выявлено:**
- ❌ Нет правил о персистентности данных между View Transitions
- ❌ Нет требований к кэшированию для SPA-like навигации
- ❌ Нет проверки на использование Cache API или других механизмов кэширования

**Что было в правилах:**
- ✅ "Обработчик `astro:page-load` для обновления клиентских библиотек" - только обновление
- ✅ "View Transitions support" - только наличие обработчика

**Что отсутствовало:**
- ❌ Требование кэширования данных между навигациями
- ❌ Проверка на использование Cache API или memory cache
- ❌ Требование анализа необходимости повторной загрузки данных

---

### 4. Использование window объекта для кэша (СРЕДНИЙ)
**Проблема:** Предложенное решение использовало `window.__graphCache`, что загрязняет глобальный namespace.

**Почему не выявлено:**
- ❌ Нет правил о запрете использования window для хранения данных
- ❌ Нет требований к использованию Cache API вместо window
- ❌ Нет проверки на загрязнение глобального namespace

**Что было в правилах:**
- ✅ "Проверка `typeof window !== 'undefined'`" - только проверка существования
- ✅ Нет правил о правильном способе кэширования

**Что отсутствовало:**
- ❌ Требование использования Cache API вместо window
- ❌ Проверка на загрязнение глобального namespace
- ❌ Требование инкапсуляции кэша

---

### 5. Отсутствие TTL и инвалидации (СРЕДНИЙ)
**Проблема:** Кэш никогда не обновлялся, даже если данные на сервере изменились.

**Почему не выявлено:**
- ❌ Нет правил о TTL для клиентского кэша
- ❌ Нет требований к механизму инвалидации
- ❌ Нет проверки на устаревшие данные

**Что было в правилах:**
- ❌ Полностью отсутствует

**Что отсутствовало:**
- ❌ Требование TTL для кэшированных данных
- ❌ Проверка механизма инвалидации
- ❌ Требование версионирования кэша

---

### 6. Отсутствие ограничения памяти (СРЕДНИЙ)
**Проблема:** Кэш мог расти бесконечно, особенно при переключении между языками.

**Почему не выявлено:**
- ❌ Нет правил о ограничении памяти для клиентского кэша
- ❌ Нет требований к LRU eviction или другим стратегиям
- ❌ Нет проверки на утечки памяти в кэше

**Что было в правилах:**
- ❌ Полностью отсутствует

**Что отсутствовало:**
- ❌ Требование ограничения размера кэша
- ❌ Проверка стратегии eviction (LRU, FIFO)
- ❌ Требование очистки неиспользуемых данных

---

### 7. Отсутствие метрик (НИЗКИЙ)
**Проблема:** Невозможно измерить эффективность кэширования и найти проблемы.

**Почему не выявлено:**
- ❌ Нет правил о метриках производительности
- ❌ Нет требований к мониторингу кэша
- ❌ Нет проверки на наличие инструментов для отладки

**Что было в правилах:**
- ❌ Полностью отсутствует

**Что отсутствовало:**
- ❌ Требование метрик для кэша (hits, misses, errors)
- ❌ Проверка наличия инструментов для отладки
- ❌ Требование логирования метрик в dev режиме

---

## Корневые причины пропуска

### 1. Фокус на функциональности, а не на производительности
- Правила проверяли, что код работает, но не проверяли, как эффективно он работает
- Нет требований к анализу network requests и производительности

### 2. Отсутствие секции про Client-Side Caching
- Правила покрывают серверное кэширование (HTTP headers), но не клиентское
- Нет понимания, что View Transitions требуют специального подхода к кэшированию

### 3. Неполное покрытие Custom Elements lifecycle
- Правила проверяют только `connectedCallback()`, но не `disconnectedCallback()`
- Нет требований к cleanup и предотвращению memory leaks

### 4. Отсутствие требований к архитектуре кэширования
- Нет правил о выборе механизма кэширования (Cache API vs window vs memory)
- Нет требований к двухуровневому кэшированию

### 5. Недостаточная проверка edge cases
- Правила проверяют основные сценарии, но не edge cases (множественные компоненты, переключение языков)
- Нет требований к анализу взаимодействия компонентов

---

## Выводы

**Основные пробелы:**
1. Отсутствие секции про Client-Side Caching
2. Неполное покрытие Custom Elements lifecycle
3. Отсутствие требований к производительности и оптимизации
4. Нет правил о предотвращении дублирования запросов
5. Отсутствие требований к метрикам и мониторингу

**Приоритеты для добавления:**
1. **КРИТИЧНО:** Секция про Client-Side Caching
2. **КРИТИЧНО:** Требования к cleanup в Custom Elements
3. **ВЫСОКИЙ:** Правила о предотвращении дублирования запросов
4. **СРЕДНИЙ:** Требования к TTL и инвалидации
5. **СРЕДНИЙ:** Правила об ограничении памяти
6. **НИЗКИЙ:** Требования к метрикам
